\chapter{Результаты практического применения}

В данной главе представлены результаты практического применения системы верификации Klever, разработанной на основе предложенных методов, и делаются выводы о пределах их применимости на практике.

\section{Критерии оценки результатов}
Процесс верификации крупных программных систем на языке программирования Си характеризуется показателями:
\begin{itemize}
    \item трудоемкостью получения результатов верификации;
    \item скоростью получения результатов верификации;
    \item точностью результатов верификации.
\end{itemize}

Предложенные в данной работе методы для верификации крупных программных систем на языке программирования Си нацелены прежде всего на сокращение трудоемкости и скорости верификации.
При этом необходимо показать, что точность верификации не ухудшилась.

Трудоемкость верификации зависит от трудозатрат, которые необходимы для конфигурирования и разработки спецификаций.
Скорость получения результатов определяется суммарным временем работы системы верификации, за которое выполняется генерация и решение верификационных задач.
Точность верификации будем рассматривать с точки зрения числа пропускаемых ошибок, числа предупреждений об ошибках и долей среди них истинных и ложных предупреждений, а также уровнем покрытия исходного кода при верификации.

Для оценки предложенных методов были рассмотрены результаты проверки требований к драйверам и подсистемам ядра ОС Linux~\cite{linux}, а также к апплетам проекта BusyBox~\cite{busybox}, которые представлены в следующих разделах данной главы. 

\section{Верификация ОС Linux}

В данном разделе рассматриваются результаты верификации драйверов и подсистем ОС Linux при помощи системы верификации Klever.
Все результаты получены для ядра ОС Linux в конфигурации allmodconfig для архитектуры x86\_64~\footnote{Система верификации Klever позволяет верифицировать исходный код и для других архитектур, но для этого требуется подготовка соответствующих инструментов, например, CIF.}.

Драйверы представляют собой событийно-ориентированные программы, которые загружаются в память ядра ОС динамически.
Подсистемами ядра ОС Linux называются компоненты ядра, которые статически компонуются в исполняемый файл ядра ОС Linux.
Подсистемы устройств реализуют поддержку для обработчиков драйверов определенных типов, например, TTY, Serial и других.
Драйверы, как правило, редко реализуют экспортируемые функции, а точками входа драйверов являются обработчики определенных типов.
Подсистемы ядра ОС Linux являются событийно-ориентированными программами и реализуют обработчики, как и драйверы.
Однако исходный код подсистем содержит достаточно экспортируемых функций, то есть выполняет роль библиотек.
Еще одним отличием подсистем от драйверов является другой интерфейс инициализации подсистем.
Подсистемы образуют иерархию, согласно которой ядро ОС вызывает функции инициализации подсистем в начале своей работы.

В ходе экспериментов рассматривались драйвера и подсистемы ОС Linux версии 3.14.79.
Для того, чтобы оценить трудоемкость для достижения высокого уровня точности, был выбран небольшой набор драйверов из директории drivers/serial.
Данная директория содержат 49 Serial драйверов с суммарным объемом исходного кода около 30 тысяч строк.
Для данного набора были разработаны спецификации предположений об окружении, чтобы модели окружения содержали вызов всех точек входа рассматриваемых драйверов.

Система позволяет выполнять проверку требований и для остальных драйверов ОС Linux.
Всего при декомпозиции было выделено 4371 модуль с исходным кодом драйверов.
Верификационные задачи были сгенерированы для 3864 модуля, суммарный размер исходного кода которых превышает три миллиона строк кода.
Для 405 модулей не была синтезирована модель окружения из-за отсутствия функций инициализации драйвера.
Такие драйверы экспортируют функции для других и для их верификации требуется разработка дополнительных спецификаций.
Еще 102 драйвера не были верифицированы из-за ошибок и ограничений в различных компонентах системы верификации Klever.

Для оценки применимости метода агрегации были выбраны три подсистемы ядра ОС Linux.
Информация о составе подсистем представлена в таблице~\ref{table:target_subsystems}.
Для более точной оценки результатов верификации число подсистем было ограничено из-за трудоемкости процесса верификации.

\begin{table}
\centering
\begin{tabular}{| l | l | c | c |}
\hline
Подсистема & Директория & Файлов & Строк кода \\
\hline
Character Devices Support (\textit{CHAR}) & drivers/char & 5 & 4194 \\ 
\hline
General-Purpose I/O (\textit{GPIO}) & drivers/gpio & 6 & 4472 \\ 
\hline
Terminal Devices Support (\textit{TTY}) & drivers/tty & 11 & 12129 \\ 
\hline
\end{tabular}
\caption{Исследуемые подсистемы ядра Linux 3.14.}
\label{table:target_subsystems}
\end{table}

\subsection{Трудоемкость верификации}
Самым трудоемким этапом процесса верификации является разработка спецификаций требований и предположений об окружении.
%Остальные этапы либо выполняются автоматически, либо требуют существенно меньше трудозатрат.
%На практике процесс верификации всегда проходит итеративно, но трудоемкость получения первичных результатов верификации в данной таблице не отражена.
Каждый драйвер реализует обработчики различных видов, для которых требуется разработать спецификации предположений об окружении, в которых должны быть заданы ограничения на порядок вызова обработчиков и их зависимости по данным.
Чтобы достичь уровня покрытия 100\% по функциям при верификации Serial драйверов, были разработаны различные спецификации предположений об окружении для нескольких построителей моделей сценариев.
Затем были разработаны дополнительные спецификации, чтобы достичь уровня покрытия около 50\% в среднем для всех драйверов ОС Linux.
В результате были разработаны спецификации для моделирования сценариев вызова обработчиков следующих типов: block, class, pci, hid, platform, serial, usb, а также для вызова обработчиков ethernet, file, ieee80211, net device, proto, real time clocks, scsi, sequential, block, tty, urb и моделирования механизмов отложенного выполнения таких, как таймеры, очереди, тасклеты, потоки ядра kthreads, а также для моделирования прерываний.
Спецификации были разработаны для версий ОС Linux 2.6.33, 3.14, 4.6.7, но самый полный и точный набор относится к версии 3.14.
%На начальных этапах апробации использовался подход вызова обработчиков на основе эвристик и для других типов обработчиков, чтобы увеличить покрытие исходного кода при верификации без необходимости разработки спецификаций.
%Но экспериментальные результаты показали, что число ложных срабатываний в таком случае существенно возрастает.

Всего для верификации драйверов ОС Linux было разработано в сумме около 17 тыс. строк кода спецификаций предположений об окружении на специализированном языке предметной области, основанном на предложенном в данной работе расширении языка Си.
Согласно оценкам, полученным на основе разработки спецификаций автором и студентами старших курсов вузов, трудоемкость разработки спецификации для одного типа обработчиков драйверов составляет 2 человеко-недели.
В этот процесс входит разработка спецификации, тестов и итеративное уточнение спецификации на основе полученных результатов верификации для исправления выявленных недостатков.

В качестве спецификаций требований использовались 30 спецификаций корректности использования интерфейсов ядра ОС Linux драйверами, разработанные для системы LDV~Tools.
Дополнительно были разработаны модели функций для проверки корректности работы с памятью и отсутствия гонок по данным, а также был реализован ряд служебных функций для связывания моделей требований и моделей окружения.
Таким образом, всего в системе верификации Klever имеется 32 спецификации требований для проверки драйверов и подсистем ОС Linux.
Трудоемкость разработки спецификаций требований оценивалась на основе тех показателей, которые были получены от разработчиков системы верификации LDV~Tools, так как задачи разработки новых спецификаций требований в данной работе на ставилось.

Оценка трудоемкости верификации Serial драйверов, всех драйверов и подсистем при помощи предложенного метода представлена в таблице~\ref{table:difficulty}.
В первом столбце представлены этапы работы, которые необходимо выполнить пользователю, за исключением времени анализа результатов, который в данной работе не рассматривается.
В ячейках представлена оценка трудоемкости и суммарный объем кода, разработанного на соответствующем этапе.
Оценка выполнялась в соответствии со следующей схемой:
\begin{enumerate}
    \item Первые результаты были получены для Serial драйверов, для которых приведены оценки трудоемкости и объем кода, который был разработан.
    \item При переходе к верификации остальных драйверов оцениваются дополнительные трудозатраты, которые были нужны после верификации Serial драйверов с учетом уже имеющихся стратегий, построителей и спецификаций.
    Второе число в каждой ячейке показывает новый суммарный объем исходного кода.
    \item При переходе к верификации подсистем новые спецификации не разрабатывались, чтобы подтвердить возможность повторного использования уже полученных артефактов.
    Поэтому соответствующие этапы содержат только трудозатраты на улучшение уточнение и доработку стратегий и спецификаций.
\end{enumerate}

Из-за высокой сложности драйверов ядра ОС Linux трудоемкость подготовки к верификации даже небольшого набора драйверов оказывается сопоставимой с трудоемкостью разработки спецификаций для верификации всех драйверов, объем исходного кода которых более чем в сто раз превосходит соответствующий объем кода Serial драйверов. 
С одной стороны, это демонстрирует масштабируемость метода и возможность его применения к крупным программным системам.
С другой стороны, применение системы верификации Klever для верификации небольшого числа отдельных компонентов крупной программной системы может быть достаточно трудным. 

%Трудозатраты для получения представленных результатов для подсистем составили  примерно один человеко-месяц.
%Основное время было потрачено на анализ результатов, доработку стратегии выделения модулей, исправление ошибок в спецификациях и доработку построителя моделей сценариев взаимодействия для поддержки вызова функций инициализации подсистем.
%Новые спецификации требований и предположений об окружении не разрабатывались, чтобы подтвердить возможность повторного использования имеющихся артефактов.

\begin{table}
\centering
\begin{tabular}{ | l | c | c | c |}
\hline
Этап разработки& Serial Драйверы & Все драйверы & Подсистемы\\
\hline
\shortstack[l]{Стратегий \\ декомпозиции} & 
\shortstack[c]{0,25 чел. мес. \\ 100LOC Python} & 
\shortstack[c]{0 чел. мес. \\ 100LOC Python} &
\shortstack[c]{0,25 чел. мес. \\ 120LOC Python} \\
\hline
\shortstack[l]{Построителей \\ моделей сценариев} & 
\shortstack[c]{3 чел*мес \\ 3KLOC Python} &
\shortstack[c]{0 чел*мес \\ 3KLOC Python} &
\shortstack[c]{0,5 чел*мес \\ 3,5KLOC Python} \\
\hline
\shortstack[l]{Спецификаций \\ предположений \\об окружении} & 
\shortstack[c]{4,5 чел*мес \\ 7KLOC DSL} &
\shortstack[c]{5,5 чел*мес \\ 17KLOC DSL} &
\shortstack[c]{0 чел*мес \\ 17KLOC DSL} \\
\hline
\shortstack[l]{Спецификаций \\ требований} &
\shortstack[c]{6 чел*мес \\ 550LOC DSL} &
\shortstack[c]{9 чел*мес \\ 1500LOC DSL} & 
\shortstack[c]{0,25 чел*мес \\ 1500LOC DSL} \\
\hline
\textbf{Итого} & 13,75 чел*мес & 14,5 чел*мес & 1 чел*мес \\
\hline
\end{tabular}
\caption{Трудоемкость верификации драйверов и подсистем ОС Linux.}
\label{table:difficulty}
\end{table}

\subsection{Скорость верификации}
Для измерения скорости верификации использовались вычислительные машины с процессорами Intel Core i7-7700 CPU @ 3.60GHz с 4 физическими ядрами.
На решение каждой верификационной задачи отводилось 15 ГБ оперативной памяти и 900 секунд.
Для верификации использовался инструмент CPAchecker версии 1.7.

В таблице~\ref{table:speed} приведены результаты верификации драйверов ОС Linux версии 3.14.79.
При верификации проверялись наборы из 49 Serial драйверов и 3864 всех драйверов на соответствие 30 требованиям корректности использования интерфейса ядра в драйверах.
В первой таблице приведены результаты, в рамках которых генератор верификационных задач выполнял подготовку задач последовательно, а решатель не запускал экземпляры инструментов верификации параллельно.
В следующем столбце представлены результаты, когда ограничения на использование физических ядер не устанавливались, а для решения использовалась одна вычислительная машина.
В последнем столбце представлен результат при использовании 30 вычислительных машин.
Время верификации Serial драйверов не может быть меньше времени подготовки верификационных задач, которое составляет 30 минут при использовании 4 физических ядер.
При верификации всех драйверов время удается существенно сократить, так как в этом случае на работу инструмента верификации тратится гораздо больше времени по сравнению с временем подготовки верификационных задач.

\begin{table}
\centering
\begin{tabular}{| l | c | c | c |}
\hline
Верификационное задание & 2 физ. ядра & 4 физ. ядра & 30 * 4 физ. ядра \\
\hline 
Serial драйверы (30KLOC) & 5ч & 2,7ч & 0,5ч \\
\hline 
Все драйверы (3MLOC) & 600ч & 195ч & 11ч \\
\hline
\end{tabular}
\caption{Время верификации драйверов ОС Linux версии 3.14.79.}
\label{table:speed}
\end{table}

\subsection{Точность верификации}

Таблица \ref{table:coverage} представляет покрытие исходного кода драйверов из директорий drivers ядра ОС Linux версии 3.14.79 и некоторых других директорий, содержащих драйверы, приведенных для сравнения.
В таблице \ref{table:drivers} представлены результаты оценки покрытия драйверов из директорий, вложенных в директорию drivers.
В среднем покрытие драйверов из директории drivers составило 51\% по строкам и 45\% по функциям.
Такой уровень покрытия уже позволяет обнаруживать ошибки в драйверах, которых при помощи системы верификации Klever было выявлено около сотни.

Уровень покрытия исходного кода зависит от числа вызываемых в моделях окружения обработчиков.
На рисунке \ref{figure:handlers} представлена зависимость доли реализаций обработчиков драйверов наиболее популярных типов относительно числа реализаций обработчиков всех типов для ОС Linux 3.14.79. Из графика видно, что более 80\% всех обработчиков имеют тип из числа 100 наиболее популярных.
Таким образом, чтобы получить значительно больший уровень покрытия по исходному коду, потребуется затратить существенно больше усилий на разработку спецификаций предположений об окружении для поддержки новых типов обработчиков драйверов.

\begin{figure}
\centering
\begin{tikzpicture}
\begin{axis}[
    xlabel={Число типов обработчиков},
    ylabel={Доля реализаций обработчиков},
    xmin=0, xmax=700,
    ymin=0, ymax=100,
    xtick={0,100,200,300,400,500,600,700},
    ytick={0,20,40,60,80,100},
    yticklabel={\pgfmathprintnumber\tick\%}
]
\addplot coordinates {(1,15) (2,27) (3,40) (4,45) (5,48) (10,60) (20,71) (50,82) (100,88) (200,94) (300, 96) (500, 99) (700, 100)};
\end{axis}
\end{tikzpicture}
\caption{Зависимость доли реализаций обработчиков наиболее распространенных типов от числа всех обработчиков драйверов ОС Linux 3.14.}
\label{figure:handlers}
\end{figure}

\begin{table}
\centering
\begin{tabular}{ | l | l | l |}
\hline
Директория & Покрытие по строкам & Покрытие по функциям\\
\hline
arch & 46\% (3340/7222) & 21\% (103/486)\\
\hline
block & 14\% (429/2955) & 1\% (4/267)\\
\hline
crypto & 39\% (7411/18793) & 23\% (168/722)\\
\hline
drivers & 55\% (1398511/2538372) &  45\% (49820/110525) \\
\hline
net & 28\% (72746/254327) & 26\% (3455/13180) \\  	
\hline
fs & 25\% (69221/267952) & 17\% (2051/11736) \\ 	
\hline
sound & 57\% (151810/262443)  & 29\% (3029/10419) \\ 
\hline
\end{tabular}
\caption{Уровень покрытия исходного кода загружаемых модулей из различных директорий ядра ОС Linux 3.14.79.}
\label{table:coverage}
\end{table}

\begin{table}
\centering
\begin{tabular}{| l | l | l |}
\hline
Директория & Покрытие по строкам & Покрытие по функциям\\
\hline 
drivers/gpu & 13\% (13476/96446)  & 4\% (190/4626) \\  	
\hline
drivers/infiniband & 34\% (36314/104686) &  24\% (1056/4357) \\
\hline
drivers/isdn & 58\% (30777/52354) 	& 52\% (993/1877) \\
\hline
drivers/media &  47\% (118324/249319) & 27\% (2687/9677) \\
\hline
drivers/net & 66\% (363300/549366) & 62\% (15033/24147) \\
\hline
drivers/staging & 66\% (161825/244187) & 55\% (4554/8250) \\
\hline
drivers/usb & 57\% (96389/168336)  & 53\% (3796/7101) \\
\hline
drivers/video & 58\% (32225/54924) & 48\% (1127/2302) \\  
\hline
\end{tabular}
\caption{Уровень покрытия исходного кода драйверов из директории ядра ОС Linux 3.14.78.}
\label{table:drivers}
\end{table}

Serial драйверы проверялись на соответствие всем 32 требованиям.
Система верификации LDV~Tools позволяет проверять 30 правил корректности использования интерфейса ядра в драйверах из данного набора.
Но уровень точности моделей окружения в LDV~Tools не позволял выполнять проверку требований корректности работы с памятью и отсутствия гонок по данным.
Для того, чтобы оценить точность моделей окружения в сравнении с подходом, реализованным в системе верификации LDV~Tools, для выбранных драйверов были выполнены соответствующие эксперименты, результаты которых представлены в таблице~\ref{table:serialldv}.
В первой строке таблицы приведены результаты верификации Serial драйверов при помощи системы верификации Klever на соответствие всем требованиям.
Во второй строке представлены результаты верификации, полученные при помощи системы верификации Klever, только для тех требований, проверка которых может быть выполнена и при помощи системы верификации LDV~Tools.
Третья строка содержит результаты, полученные при помощи системы верификации LDV Tools.
Предупреждения, выданные в рамках системы верификации LDV~Tools, содержат существенно больше ложных предупреждений об ошибках из-за некорректных моделей окружения, которые в рамках этой системы верификации исправить не представляется возможным.
%Данный результат подтверждает, что точность моделей окружения в системе верификации Klever повысилась.

Проверка требований корректности работы с памятью и отсутствия гонок по данным стала возможной в системе верификации Klever с появлением конфигурируемого транслятора промежуточной модели окружения, который позволяет настраивать вид моделей окружения в зависимости от проверяемого требования к программе.
Новые обнаруженные ошибки демонстрируют важность данной функции на практике.

\begin{table}
\centering
\begin{tabular}{| l | c | c | c | c |}
\hline
\shortstack[l]{Верификационное \\ задание} &
\shortstack[l]{Ложное \\ предупреждение} &
Ошибка & Нет вердикта\\
\hline
\shortstack[l]{Klever, Serial \\ драйверы, расширенный \\ набор требований} & 16  & 6 & 46\\ 
\hline
\shortstack[l]{Klever, Serial \\ драйверы, сокращенный \\ набор требований} & 5  & 1 & 16\\ 
\hline
\shortstack[l]{LDV Tools, Serial \\ драйверы, сокращенный \\ набор требований} & 31  & 0 & 9\\
\hline
\end{tabular}
\caption{Вердикты при верификации Serial драйверов ОС Linux версии 3.14.79.}
\label{table:serialldv}
\end{table}

Эксперименты с подсистемами ядра ОС Linux выполнялись для исследования возможности повторного использования спецификаций при верификации, поэтому при верификации подсистем новые спецификации не разрабатывались.
Чтобы повысить уровень покрытия при верификации был использован подход агрегации подсистем с драйверами.

Чтобы выяснить, как на точность результатов влияет верификация разных версий ядра ОС с одним и тем же набором спецификаций требований и предположений об окружении, были рассмотрены версии ядра ОС Linux, начиная с 3.9, выпущенной 28 апреля 2013, и заканчивая 3.19, выпущенной 8 февраля 2015.
За рассматриваемый почти 2-х летний период разработки было выпущено 11 версий ядра.
Таблица \ref{table:target_subsystem_changes} отражает число изменений, сделанных в подсистемах за данный период.

\begin{table}
\caption{Изменения в исходном коде целевых подсистем относительно версии ОС Linux 3.14}
\label{table:target_subsystem_changes}
\centering
\begin{tabular}{ l l l }
\hline
Подсистема & Файлов добавлено/удалено & Строк добавлено/удалено\\
\hline
\textit{CHAR} & +0/-1 (+0\%/-20\%) & +950/-712 (+23\%/-17\%) \\ 
\textit{GPIO} & +2/-3 (+33\%/-50\%) & +5074/-3079 (+113\%/-69\%) \\ 
\textit{TTY} & +1/-0 (+9\%/-0\%) & +4012/-3221 (+33\%/-27\%) \\ 
\hline
\end{tabular}
\end{table}


\begin{figure}
\centering
\begin{tikzpicture}
\begin{axis}[
  width=13cm,
  height=7cm,
  grid=major,
  xlabel=Версия ядра Linux,
  ylabel=Покрытие по функциям,
  xtick=data,
  xticklabels={3.9,3.10,3.11,3.12,3.13,3.14,3.15,3.16,3.17,3.18,3.19},
  yticklabel={\pgfmathprintnumber\tick\%},
  ymin=40,
  ymax=100,
  legend style={
    at={(0.95,0.5)},
    anchor=west
  }
]
\addplot coordinates {(0,77.2) (1,78.8) (2,78.6) (3,78.6) (4,77.6) (5,77.6)	(6,76.2) (7,76.2) (8,74.0) (9,73.8)	(10,73.8)};
\addlegendentry{CHAR}
\addplot coordinates {(0,53.0) (1,51.8) (2,54.2) (3,54.7) (4,49.7) (5,59.1)	(6,53.5) (7,59.6) (8,63.6) (9,64.3)	(10,54.2)};
\addlegendentry{GPIO}
\addplot coordinates {(0,81.2) (1,80.7) (2,76.5) (3,82.9) (4,82.9) (5,83.0)	(6,82.5) (7,82.5) (8,82.5) (9,82.7)	(10,83.0)};
\addlegendentry{TTY}
\end{axis}
\end{tikzpicture}
\caption{Уровень покрытия по функциям исходного кода целевых подсистем.}
\label{figure:func_coverage}
\end{figure}

График на рисунке~\ref{figure:func_coverage} отражает покрытие по функциям в зависимости от версии ядра ОС Linux.
Покрытие подсистем CHAR и TTY меняется незначительно.
В подсистеме TTY в версии 3.11 был добавлен новый файл с определениями семафоров, которые на тот момент еще не использовались в других файлах подсистемы или драйверов, что вызвало падение покрытия при верификации.
Покрытие по функциям подсистемы GPIO меняется значительно из-за активной разработки подсистемы в рассматриваемый период.
Подсистема была добавлена в 2008~\cite{gpio} и достаточно активно менялась в отличие от CHAR и TTY еще долгое время.
Насколько значительно изменялись подсистемы относительно версии ядра ОС Linux 3.14 можно видеть из таблицы \ref{table:target_subsystem_changes}.

\begin{figure}
\centering
% \subfigure[Total statistics]{
% \begin{tikzpicture}
% \pie[radius=2, scale font, text=legend, sum=auto]{
%   105/Absent environment model specifications,
%   40/Invoked from other subsystems,
%   10/Replaced with models,
%   10/No invocations at all,
%   9/Another architecture and configuration
% }
% \end{tikzpicture}
% }
% \subfigure[Statistics for each subsystem]{
\begin{tikzpicture} \begin{axis}[ 
  ybar,
  enlargelimits=0.25,
  legend style={
    at={(0.8,0.75)},
    anchor=west
  },
  ylabel=Непокрытие функции,
  symbolic x coords={CHAR,GPIO,TTY},
  xtick=data,
  nodes near coords,
  nodes near coords align={vertical}
]
\addplot coordinates {(CHAR,14) (GPIO,46) (TTY,45)};
\addplot coordinates {(CHAR,9) (GPIO,15) (TTY,16)};
\addplot coordinates {(CHAR,2) (GPIO,0) (TTY,8)};
\addplot coordinates {(CHAR,1) (GPIO,5) (TTY,4)};
\addplot coordinates {(CHAR,0) (GPIO,5) (TTY,4)};
\legend{Нет спецификаций,Вызов из другой подсистемы,Функция заменена моделью,Функция не вызывается,Другая архитектура/конфигурация}
\end{axis}
\end{tikzpicture}
% }
\caption{Причины отсутствия покрытия функций для исследуемых подсистем из ядра ОС Linux версии 3.14.}
\label{figure:func_no_coverage}
\end{figure}

На диаграмме на рисунке \ref{figure:func_no_coverage} отражены причины отсутствия покрытия по функциям.
Для вызова некоторых обработчиков требовалась разработка спецификаций предположений об окружении.
Некоторые функции, которые вызывались только из другой подсистемы, требовали добавления в состав агрегаций еще и других подсистем, а не только драйверов, но этот подход не был реализован.
Некоторые функции вовсе не имели вызовов в рассматриваемых версиях ядра.
Ряд функций вызывался только в исходном коде, предназначенном для другой архитектуры или конфигурации ядра.

\begin{figure}
\centering
\begin{tikzpicture}
\begin{axis}[
  width=13cm,
  height=7cm,
  grid=major,
  xlabel=Версия ядра Linux,
  ylabel=Среднее число вердиктов,
  xtick=data,
  xticklabels={3.9,3.10,3.11,3.12,3.13,3.14,3.15,3.16,3.17,3.18,3.19},
  legend style={
    at={(0.95,0.5)},
    anchor=west
  }
]
\addplot[blue,mark=*]         coordinates {(0,9.0) (1,9.0) (2,9.0) (3,9.0) (4,9.0) (5,9.0) (6,9.0) (7,9.0) (8,9.0) (9,9.0) (10,9.0)};
\addlegendentry{CHAR True}
\addplot[red,mark=*]          coordinates {(0,9.0) (1,8.1) (2,8.8) (3,8.6) (4,8.6) (5,8.7) (6,8.8) (7,9.8) (8,8.8) (9,8.8) (10,10.2)};
\addlegendentry{GPIO True}
\addplot[brown,mark=*]        coordinates {(0,7.4) (1,7.4) (2,7.4) (3,7.4) (4,7.4) (5,7.4) (6,7.4) (7,7.4) (8,7.4) (9,7.5) (10,7.5)};
\addlegendentry{TTY True}
\addplot[blue,mark=square*]   coordinates {(0,0.0) (1,0.0) (2,0.0) (3,0.0) (4,0.0) (5,0.0) (6,0.0) (7,0.0) (8,0.0) (9,0.0) (10,0.0)};
\addlegendentry{CHAR False}
\addplot[red,mark=square*]    coordinates {(0,0.5) (1,0.5) (2,0.5) (3,0.5) (4,0.5) (5,0.6) (6,0.9) (7,0.8) (8,1.8) (9,1.7) (10,0.5)};
\addlegendentry{GPIO False}
\addplot[brown,mark=square*]  coordinates {(0,0.6) (1,0.3) (2,0.3) (3,0.7) (4,0.8) (5,0.7) (6,0.7) (7,0.7) (8,0.7) (9,0.6) (10,0.3)};
\addlegendentry{TTY False}
\addplot[blue,mark=diamond*]  coordinates {(0,3.0) (1,3.0) (2,3.0) (3,3.0) (4,3.0) (5,3.0) (6,3.0) (7,3.0) (8,3.0) (9,3.0) (10,3.0)};
\addlegendentry{CHAR Unknown}
\addplot[red,mark=diamond*]   coordinates {(0,2.5) (1,3.4) (2,2.8) (3,2.9) (4,2.9) (5,2.7) (6,2.3) (7,1.4) (8,1.5) (9,1.5) (10,1.2)};
\addlegendentry{GPIO Unknown}
\addplot[brown,mark=diamond*] coordinates {(0,4.0) (1,4.3) (2,4.3) (3,3.9) (4,3.8) (5,3.9) (6,3.9) (7,3.9) (8,3.9) (9,3.9) (10,4.2)};
\addlegendentry{TTY Unknown}
\end{axis}
\end{tikzpicture}
\caption{Среднее число вердиктов при верификации целевых подсистем в зависимости от версии ОС Linux.}
\label{figure:verdicts}
\end{figure}

Целевые подсистемы были верифицированы на соответствие 12 релевантным требованиям: memory, alloc:\{irq, spinlock\}, arch:io, base:\{class, dma-mapping\}, fs:sysfs, locking:\{mutex, rwlock, spinlock\}, kernel:module, rcu:update:lock.
На рисунке~\ref{figure:verdicts} представлено изменение результатов верификации в зависимости от версии ядра.
Среднее число вердиктов позволяет на одном графике сравнить результаты для всех трех подсистем. 
Причины изменений можно видеть из графиков с покрытием функций в зависимости от версии ядра ОС Linux~\ref{figure:func_coverage}.
Например, в версии Linux 3.17 и Linux 3.18 была внесена ошибка, которая обнаруживалась Klever при проверке требования locking:spinlock.

В подсистемах CHAR и TTY не было найдено ошибок.
При верификации подсистемы TTY 62\% ложных сообщений об ошибках относились к подсистеме, а остальные 38\% относились к драйверам, с которыми проверялась подсистема.
Все ложные сообщения были вызваны неточностью спецификаций предположений об окружении.
В подсистеме GPIO 51\% всех вердиктов False являются подтвержденными ошибками.
Одна из ошибок уже упомянута и была внесена в исходный код ОС Linux в версии 3.17 и исправлена в версии 3.19.
Еще 2 ошибки были найдены в драйверах и не были исправлены в новых версиях ядра.
Для подсистемы GPIO 59\% ложных сообщений об ошибках относились к исходному коду подсистемы и 41\% к драйверам.
Причиной 86\% ложных сообщений об ошибках являются неточные спецификации предположений об окружении, а 14\% вызваны неточностью инструмента верификации CPAchecker.

% CHAR: 77
% GPIO: 130
% TTY: 281
Также для выбранных версий ядра была попытка обнаружить ошибки, исправленные в рассматриваемый период и которые нарушают требования, проверку которых можно осуществить при помощи системы верификации Klever.
Для этого были проанализированы вручную 488 изменений, исключая слияния веток, сделанные начиная с версии 3.9 и заканчивая 3.19 в репозитории ОС Linux~\cite{linuxrepo}.
Среди найденных исправлений ошибок были найдены 8 подходящих, представленные в таблице~\ref{table:target_subsystem_faults}.

\begin{table}
\centering
\begin{tabular}{ c l l l }
\hline
Название & Изменение & Требование & Статус \\
\hline
\multirow{3}{*}{\textit{CHAR}} & 08d2d00b291e & \textit{memory} & \ding{55} (Иная конфигурация) \\ 
                               & b5325a02aa84 & \textit{memory} & \ding{51}  \\ 
                               & 61c6375d5523 & \textit{memory} & \ding{55} (Иная конфигурация) \\ 
\hline
\multirow{2}{*}{\textit{GPIO}} & e9595f84a627 & \textit{memory} & \ding{51} \\ 
                               & 00acc3dc2480 & \textit{locking:spinlock} & \ding{51} \\ 
\hline
\multirow{3}{*}{\textit{TTY}}  & b216df538481 & \textit{memory} & \ding{55} (Ограничение инструмента) \\ 
                               & 07584d4a356e & \textit{kernel:module} & \ding{51}  \\ 
                               & 1d9e689c934b & \textit{memory} & \ding{55} (Не хватило ресурсов) \\  
\hline
\end{tabular}
\caption{Результат поиска известных ошибок в рассматриваемых подсистемах.}
\label{table:target_subsystem_faults}
\end{table}

Ошибка из изменения \textit{00acc3dc2480} была уже упомянута и была успешно обнаружена Klever.
Для поиска ошибок из \textit{b5325a02aa84} и \textit{e9595f84a627} потребовалось добавить больше драйверов в агрегации, с которыми верифицировалась подсистема из-за нехватки моделей некоторых неопределенных функций.
Ошибка \textit{07584d4a356e} как таковая не была обнаружена, но инструмент доказал недостижимость данного исходного кода из-за другой ошибки в подсистеме.

Чтобы обнаружить ошибку, исправленную в \textit{08d2d00b291e}, требовалось анализировать исходный код подсистемы \textit{CHAR} для архитектуры \textit{x86\_32}.
Для обнаружения ошибки, исправленной в \textit{61c6375d5523}, необходимо было использовать конфигурацию, отличную от \textit{allmodconfig}.
Чтобы найти ошибку до исправления \textit{b216df538481} требовался более точный анализ вызовов по функциональным указателям, который не был реализован в соответствующей версии CPAchecker на момент выполнения экспериментов.
Из-за недостаточной масштабируемости данного инструмента верификации моделей программ также не удалось обнаружить ошибку, исправленную в \textit{1d9e689c934b}.

\section{Верификация апплетов проекта BusyBox}
В отличие от драйверов и подсистем ОС Linux проект BusyBox содержит пользовательские программы, которые имеют одну точку входа и являются преобразующими с точки зрения устройства.
Чтобы продемонстрировать возможность применения системы верификации Klever и к таким программных системам, были выполнены соответствующие эксперименты.
В данном разделе представлены результаты верификации проекта BusyBox версии 1.28.3 в конфигурации alldefconfig для архитектуры x86\_64.

\subsection{Трудоемкость верификации}
Подготовка к верификации апплетов BusyBox состояла из следующих этапов:
\begin{itemize}
    \item разработка стратегии выделения модулей и спецификации декомпозиции;
    \item разработка спецификаций предположений об окружении с моделями функций стандартной библиотеки;
    \item разработка спецификаций требований.
\end{itemize}
Так как каждый апплет имеет одну точку входа, то разработка спецификаций для моделирования сценариев не потребовалась, поэтому был использован построитель моделей сценариев, который выполняет подготовку промежуточной модели окружения полностью автоматически.
Суммарное время выполнения данных этапов составило около одного человеко-месяца и представлено в таблице~\ref{busybox:difficulty}.

Для проверки требований были разработаны две спецификации.
Проверка требования корректности работы с файловыми дескрипторами была сведена к проверке свойства недостижимости ошибочного оператора, а для проверки требования корректности работы с памятью потребовалось разработать ряд моделей функций стандартной библиотеки. 
Для сокращения числа ложных предупреждений об ошибках были разработаны 34 модели различных функций.

\subsection{Скорость верификации}
Для верификации использовалась 8-ядерная виртуальная машина, работающая на процессорах \mbox{Intel Xeon E312xx} (Sandy~Bridge) CPU, с 64~Гб оперативной памяти.
Для решения верификационных задач был использован инструмент верификации моделей программ CPAchecker.
На решение каждой верификационной задачи отводилось 15 Гб оперативной памяти и 900 секунд процессорного времени.

Время верификации составило 5,5 и 7 часов при проверке корректности работы с памятью и корректности использования файловых дескрипторов соответственно.
По сравнению с верификацией драйверов ОС Linux заметно существенно снижение скорости работы инструмента верификации при верификации апплетов, что было вызвано невозможностью использования слайсера при подготовке верификационных задач.

\subsection{Точность верификации}
При верификации апплеты проверялись на соответствие требованиям корректности работы с файловыми дескрипторами и памятью.
Уровень покрытия при верификации составил 97\% по строкам и 94\% по функциям.

При проверке требования корректности работы с памятью приемлемого уровня точности достигнуть не удалось.
Основным ограничением в данном случае стала недостаточная точность моделирования операций со строками в инструменте верификации моделей программ CPAchecker.

Результаты проверки требования корректности работы с файловыми дескрипторами приведены в таблице~\ref{table:busy}.
Нарушение проверяемого требования апплетом ssl\_client отмечено как истинное предупреждение, так как апплет требует в качестве входных данных передачи уже открытых файловых дескрипторов, что было запрещено формальной моделью требования.
Одна ложная ошибка была вызвана неточной моделью аргументов командной строки апплета, а в остальных 5 случаях причиной стала недостаточная точностью инструмента верификации при моделировании операций с массивами, функциональными указателями и битовыми векторами.
Для 105 апплетов вердикт не удалось получить за приемлемое время из-за проблемы взрыва числа состояний в модели. 
Еще 23 апплета не были проверены из-за ошибок в инструменте CIF.

\begin{table}
\centering
\begin{tabular}{ | l | c | c | c |}
\hline
Этап разработки& BusyBox\\
\hline
\shortstack[l]{Стратегий \\ декомпозиции} & 
\shortstack[c]{0,25 чел. мес. \\ 100LOC Python} \\ 
\hline
\shortstack[l]{Построителей \\ моделей сценариев} & 
\shortstack[c]{0 чел*мес} \\
\hline
\shortstack[l]{Спецификаций \\ предположений \\об окружении} & 
\shortstack[c]{0,25 чел*мес \\ 200LOC DSL} \\
\hline
\shortstack[l]{Спецификаций \\ требований} &
\shortstack[c]{0,5 чел*мес \\ 300LOC DSL} \\
\hline
\textbf{Итого} & 1 чел*мес \\
\hline
\end{tabular}
\caption{Трудоемкость верификации апплетов проекта BusyBox.}
\label{busybox:difficulty}
\end{table}

\begin{table}
\centering
\begin{tabular}{| l | c | }
\hline
Вердикт & Число апплетов\\
\hline
False (ложный) & 6 \\
\hline
False (истинный) & 1 \\
\hline
True & 159 \\
\hline
Unknown & 133 \\
\hline
\end{tabular}
\caption{Вердикты, полученные при верификации апплетов проекта BusyBox.}
\label{table:busy}
\end{table}

\section{Область применимости и ограничения метода}

Результаты практического применения системы Klever показали возможность успешного применения метода к крупным программным системам на языке программирования Си с расширениями GNU, модули которых устроены как библиотеки, событийно-ориентированные или преобразующие программы.
Исследовались как компоненты ядра ОС Linux, так и пользовательские программы на примере проекта BusyBox.

Наиболее трудоемким этапом при верификации является разработка спецификаций требований и предположений об окружении.
На примере верификации драйверов и подсистем ОС Linux было продемонстрировано, что предложенный подход имеет существенно более низкую трудоемкость по сравнению с разработкой моделей окружения вручную, а также позволяет достичь более высокого уровня точности моделей окружения по сравнению с подходом генерации моделей окружения на основе эвристик, реализованном в системе верификации LDV~Tools.
Результаты, полученные для проекта BusyBox, показывают, что трудоемкость верификации преобразующих программ с небольшим числом точек входа не требует так много усилий, как при верификации библиотек и событийно-ориентированных программ, для которых может потребоваться разработка новых компоновщиков моделей сценариев взаимодействия и большого объема спецификаций предположений об окружении.

Предложенный метод также ограничен возможностями современных инструментов верификации моделей программ, которые имеют невысокую масштабируемость и не всегда поддерживают моделирование операций в исходном коде программы с надлежащей точностью.
Если не удается подобрать подходящий инструмент верификации для верификации определенной программной системы на языке Си, то для такой программы трудно получить результаты с высоким уровнем качества.

Предложенные методы реализованы в системе верификации Klever, которую целесообразно применять для проверки требований к крупным программным системам на языке Си с расширениями GNU, которые имеют событийно-ориентированную архитектуру.
Во-первых, предложенный метод в таком случае позволяет существенно сократить трудоемкость применения инструментов верификации моделей программ.
Во-вторых, к модулям таких программ может быть трудно применять другие методы верификации, из-за чего повышается риск пропустить ошибки, которые могут существенно снизить надежность и безопасность исследуемой программы.